'''
一 常用模块
###################################################################
1.sys模块
  sys.argv 命令行输入
    eg:python中的sys模块就是传入命令行非常方便 执行python 1.py case1 case2 case3时，python中sys.argv[1]=case1，sys.argv[2]=case2以此类推
  sys.platform 当前平台
    eg:print sys.platform结果为win32
  sys.path 模块的搜索路径
    eg:sys.path.append("dfdf"):对于模块和自己写的程序不在同一个目录下，可以把模块的路径通过sys.path.append(路径)添加到程序中。
    经典用法：
            CONF_PATH = os.path.dirname(os.path.abspath(__file__)) + "/../conf/"
            sys.path.append(CONF_PATH)
  sys.stdout 标准输出 :重定向的时候要注意先保存标准输出流,print==sys.stdout.write("dfdfd"\n)
  eg:
    import sys
    savedStdout = sys.stdout  #保存标准输出流
    with open('out.txt', 'w+') as file:
        sys.stdout = file  #标准输出重定向至文件
        print 'This message is for file!'

    sys.stdout = savedStdout  #恢复标准输出流
    print 'This message is for screen!'   
 
 sys.stdin 标准输入 
  eg:
    for line in sys.stdin:
       print line
 sys.exit()
##################################################################
2.os模块
  1  os.name      #显示当前使用的平台
      >>> os.name
      'nt'                  #这表示Windows
      >>> os.name
      'posix'             #这表示Linux
  2  os.getcwd()      #显示当前python脚本工作路径
  3  os.listdir('dirname')        #返回指定目录下的所有文件和目录名
  4  os.remove('filename')       #删除一个文件
  5  os.makedirs('dirname/dirname')     #可生成多层递规目录
  6  os.rmdir('dirname')     #删除单级目录
  8  os.system()    #运行shell命令,注意：这里是打开一个新的shell，运行命令，当命令结束后，关闭shell
        >>> os.system('pwd')
            /root/hahaha
  9  os.path.abspath(path)    #显示当前绝对路径
  10  os.path.dirname(path)    #返回该路径的父目录
  11  os.path.join(path,name)   #连接目录与文件名或目录 结果为path/name
    >>> os.path.join('/root/haha','test')
    '/root/haha/test'
  12 os.chdir(path): 方法用于改变当前工作目录到指定的路径。
  13 os.path.exists(path)
######################################################################
3.re模块
  Python特别设计了原始字符串(raw string)，需要提醒你的是，在写文件路径的时候就不要使用raw string了，这里存在陷阱。
  raw string就是用'r'作为字符串的前缀，如 r"\n"：表示两个字符"\"和"n"，而不是换行符了。Python中写正则表达式时推荐使用这种形式。
  
  二、正则表达式元字符说明：
    .    匹配除换行符以外的任意字符
    ^    匹配字符串的开始
    $    匹配字符串的结束
    []   用来匹配一个指定的字符类别
    ？   对于前一个字符字符重复0次到1次
    *对于前一个字符重复0次到无穷次
    {}   对于前一个字符重复m次
    {m，n} 对前一个字符重复为m到n次
    \d   匹配数字，相当于[0-9]
    \D   匹配任何非数字字符，相当于[^0-9]
    \s   匹配任意的空白符，相当于[ fv]
    \S   匹配任何非空白字符，相当于[^ fv]
    \w   匹配任何字母数字字符，相当于[a-zA-Z0-9_]
    \W   匹配任何非字母数字字符，相当于[^a-zA-Z0-9_]
    \b   匹配单词的开始或结束
  re方法：
   re.compile 可以把正则表达式编译成一个正则对象
   re.findall 在目标字符串查找符合规则的字符串
   re.search 函数会在字符串内查找模式匹配，只到找到第一个匹配然后返回，如果字符串没有匹配，则返回None。
   re.match 尝试从字符串的开始匹配一个模式，也等于说是匹配第一个单词
   注意：re.match与re.search的区别：re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；
   而re.search匹配整个字符串，直到找到一个匹配。
   
    Python通过re模块提供对正则表达式的支持。使用re的一般步骤是先使用re.compile()函数，将正则表达式的字符串形式编译为Pattern实例，
    然后使用Pattern实例处理文本并获得匹配结果（一个Match实例），最后使用Match实例获得信息，进行其他的操作。
      eg：
      import re
      pattern = re.compile('[a-zA-Z]')
      result = pattern.findall('as3SiOPdj#@23awe')
      print result
      # ['a', 's', 'S', 'i', 'O', 'P', 'd', 'j', 'a', 'w', 'e']
######################################################################
'''
文件操作
工作模式
      ‘r’模式:以读方式打开，不能进行写操作，文件必须是已经存在的
      ‘r+’模式：以读写方式打开，文件必须是已经存在的
      ‘w’模式：以写方式打开，不能进行读操作，若文件存在，则先清空，然后重新创建；若不存在，则创建文件
      ‘w+’模式：以读写方式打开，若文件存在，则先清空，然后重新创建；若不存在，则创建文件
      ‘a’模式：以追加方式打开，不能进行读操作，把数据追加到文件的末尾；若不存在，则创建文件
      ‘a+’模式：以读写方式打开，把数据追加到文件的末尾；若不存在，则创建文件
      ‘b’模式：以二进制模式打开，不能作为第一个字符出现，需跟以上模式组合使用，
1.读取写入文件
  python中有三个方法来处理文件内容的输入：
    read() 一次读取全部的文件内容。
    readline() 每次读取文件的一行。
    readlines() 读取文件的所有行，返回一个字符串列表。
   
    f=open("path","r/w/a+")
    kk=f.read()
    print kk
    f.close()
 2.多行写入  
   l = ['\nhello dear!','\nhello son!','\nhello baby!\n']
   f = open('/tmp/test.txt','a')
   f.writelines(l)
   f.close()
##一次性往文件中写入多行##############################
    '''
    list=['1    nihao  com.com','nidaye','sfdsfsdf']
    path="D:\pythonCode/4.txt"
    f=open(path,'w')
    f.seek(0)
    for line in list:
        f.writelines(line+'\n')
    f.close()
    '''
###################################################
#如何判断一个文件有多少行#############################
    '''
    path="D:\pythonCode/4.txt"
    length=len(open(path).readlines())
    print length
    '''
##################################################
#读取一个.txt文件中的内容，按要求取得所需要的内容######
    """
    def main():
        print 'dkkdfd'
        path="D:\pythonCode/2.txt"
        comts=read_comts(path)
        print comts

    def read_comts(comt_dir):
        comts = {}
        context={}
        try:
            with open(comt_dir) as read_file:
                for line in read_file:
                    splits=line.split('\t')
                    if(len(splits)<2):
                        continue
                    comtid, content = splits[:2]
                    comts[comtid]=1
                    context[comtid]=content
        except IOError:
            raise Exception('read comt file %s failed' % comt_dir)
        return comts,context

    if __name__ == '__main__':
        main()
    """
###################################################
   
'''
##########################################################
'''
  切片详解：
  li = [1,2,3,4,5,6,7]
  print li[1:]           #输出[2,3,4,5,6,7]，省略终止索引，表示取起始索引之后的所有值，等效于li[1:len(li)]
  print li[:3]           #输出[1,2,3]，省略起始索引，表示从0开始取，等效于li[0:3]
  print li[:]            #输出[1,2,3,4,5,6,7]，省略起始索引、终止索引、步长值表示取全部，等效于li[0:len(li):1]
  print li[::]           #输出[1,2,3,4,5,6,7]，省略起始索引、终止索引、步长值表示取全部，等效于li[0:len(li):1]
  print li[::-1]        #输出[7,6,5,4,3,2,1]，省略起始索引、终止索引，步长值为-1，表示反向获取
  
  注：在切片运算中，步长为正，表示从左至右，按照索引值与起始位置索引之差可以被步长整除的规律取值；当步长为负，则表示从右至左，按照
  按照索引值与起始位置索引之差可以被步长整除的规律取值。
  根据这个特性，我们可以很方便对某个序列进行倒序取值，这个方法比reverse方法更方便，且适用于没有reverse方法的字符串和元组。
'''
##########################################################
'''
1.列表
  不用声明可以直接使用，并且一个数组中可以存储多种不同的数据类型（包括另外的列表，元组，字典）
  a=['1','2','3']
    list.remove(value)  删除指定的值
    list.pop()  删除末尾的值
    list.insert(index,value) 在指定位置插入值 
    list.reverse() 翻转数组
    list.append(value)  在数组末尾追加一个值
    list.extend(list1)  在数组末尾追加另一个数组
  判断数据类型：
    a = 111
    isinstance(a, int)
    True
    
 2.字典
    字典的两个重要特性：
      1.不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住。
      2.键必须不可变，所以可以用数，字符串或元组充当，所以用列表就不行   
        eg:dict = {['Name']: 'Zara', 'Age': 7} print dict['Name']
      删除操作：
        del dict['Name']; # 删除键是'Name'的条目
        dict.clear();     # 清空词典所有条目
        del dict ;        # 删除词典
      常用方法：
      1、radiansdict.clear()：删除字典内所有元素
      2、radiansdict.copy()：返回一个字典的浅复制
      3、radiansdict.fromkeys()：创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值
      4、radiansdict.get(key, default=None)：返回指定键的值，如果值不在字典中返回default值
      5、radiansdict.has_key(key)：如果键在字典dict里返回true，否则返回false
      6、radiansdict.items()：以列表返回可遍历的(键, 值) 元组数组
      7、radiansdict.keys()：以列表返回一个字典所有的键
      8、radiansdict.setdefault(key, default=None)：和get()类似, 但如果键不已经存在于字典中，将会添加键并将值设为default
      9、radiansdict.update(dict2)：把字典dict2的键/值对更新到dict里
      10、radiansdict.values()：以列表返回字典中的所有值
  
'''
##########################################################
'''
无参装饰器：
    def deco(func):
      def _deco():
        print 'before addd'
        func()
        print 'after addd'
      return _deco
   
    @deco
    def myfunc():
      print 'lallalal'

    myfunc()

有参数装饰器：
def deco(arg):
  def _deco(func):
    def __deco():
      print '1'
      func()
      print '2'
    return __deco
  return _deco

@deco("hello")
def myfunc():
  print 'nihao'

myfunc()

函数参数传递装饰器：
def deco(arg):
  def _deco(func):
    def __deco(str):
      print '1'
      func(str)
      print '2'
    return __deco
  return _deco

@deco("hello")
def myfunc(str):
  print 'nihao',str 

myfunc("lala")
'''

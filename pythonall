'''
一 常用模块
###################################################################
1.sys模块
  sys.argv 命令行输入
    eg:python中的sys模块就是传入命令行非常方便 执行python 1.py case1 case2 case3时，python中sys.argv[1]=case1，sys.argv[2]=case2以此类推
  sys.platform 当前平台
    eg:print sys.platform结果为win32
  sys.path 模块的搜索路径
    eg:sys.path.append("dfdf"):对于模块和自己写的程序不在同一个目录下，可以把模块的路径通过sys.path.append(路径)添加到程序中。
    经典用法：
            CONF_PATH = os.path.dirname(os.path.abspath(__file__)) + "/../conf/"
            sys.path.append(CONF_PATH)
  sys.stdout 标准输出 :重定向的时候要注意先保存标准输出流,print==sys.stdout.write("dfdfd"\n)
  eg:
    import sys
    savedStdout = sys.stdout  #保存标准输出流
    with open('out.txt', 'w+') as file:
        sys.stdout = file  #标准输出重定向至文件
        print 'This message is for file!'

    sys.stdout = savedStdout  #恢复标准输出流
    print 'This message is for screen!'   
 
 sys.stdin 标准输入 
  eg:
    for line in sys.stdin:
       print line
 sys.exit()
##################################################################
2.os模块
  1  os.name      #显示当前使用的平台
      >>> os.name
      'nt'                  #这表示Windows
      >>> os.name
      'posix'             #这表示Linux
  2  os.getcwd()      #显示当前python脚本工作路径
  3  os.listdir('dirname')        #返回指定目录下的所有文件和目录名
  4  os.remove('filename')       #删除一个文件
  5  os.makedirs('dirname/dirname')     #可生成多层递规目录
  6  os.rmdir('dirname')     #删除单级目录
  8  os.system()    #运行shell命令,注意：这里是打开一个新的shell，运行命令，当命令结束后，关闭shell
        >>> os.system('pwd')
            /root/hahaha
  9  os.path.abspath(path)    #显示当前绝对路径
  10  os.path.dirname(path)    #返回该路径的父目录
  11  os.path.join(path,name)   #连接目录与文件名或目录 结果为path/name
    >>> os.path.join('/root/haha','test')
    '/root/haha/test'
  12 os.chdir(path): 方法用于改变当前工作目录到指定的路径。
######################################################################
'''
文件操作
工作模式
      ‘r’模式:以读方式打开，不能进行写操作，文件必须是已经存在的
      ‘r+’模式：以读写方式打开，文件必须是已经存在的
      ‘w’模式：以写方式打开，不能进行读操作，若文件存在，则先清空，然后重新创建；若不存在，则创建文件
      ‘w+’模式：以读写方式打开，若文件存在，则先清空，然后重新创建；若不存在，则创建文件
      ‘a’模式：以追加方式打开，不能进行读操作，把数据追加到文件的末尾；若不存在，则创建文件
      ‘a+’模式：以读写方式打开，把数据追加到文件的末尾；若不存在，则创建文件
      ‘b’模式：以二进制模式打开，不能作为第一个字符出现，需跟以上模式组合使用，
1.读取写入文件
  python中有三个方法来处理文件内容的输入：
    read() 一次读取全部的文件内容。
    readline() 每次读取文件的一行。
    readlines() 读取文件的所有行，返回一个字符串列表。
   
    f=open("path","r/w/a+")
    kk=f.read()
    print kk
    f.close()
 2.多行写入  
   l = ['\nhello dear!','\nhello son!','\nhello baby!\n']
   f = open('/tmp/test.txt','a')
   f.writelines(l)
   f.close()
##一次性往文件中写入多行##############################
    '''
    list=['1    nihao  com.com','nidaye','sfdsfsdf']
    path="D:\pythonCode/4.txt"
    f=open(path,'w')
    f.seek(0)
    for line in list:
        f.writelines(line+'\n')
    f.close()
    '''
###################################################
#如何判断一个文件有多少行#############################
    '''
    path="D:\pythonCode/4.txt"
    length=len(open(path).readlines())
    print length
    '''
##################################################
#读取一个.txt文件中的内容，按要求取得所需要的内容######
    """
    def main():
        print 'dkkdfd'
        path="D:\pythonCode/2.txt"
        comts=read_comts(path)
        print comts

    def read_comts(comt_dir):
        comts = {}
        context={}
        try:
            with open(comt_dir) as read_file:
                for line in read_file:
                    splits=line.split('\t')
                    if(len(splits)<2):
                        continue
                    comtid, content = splits[:2]
                    comts[comtid]=1
                    context[comtid]=content
        except IOError:
            raise Exception('read comt file %s failed' % comt_dir)
        return comts,context

    if __name__ == '__main__':
        main()
    """
###################################################
   
'''
##########################################################
'''
  切片详解：
  li = [1,2,3,4,5,6,7]
  print li[1:]           #输出[2,3,4,5,6,7]，省略终止索引，表示取起始索引之后的所有值，等效于li[1:len(li)]
  print li[:3]           #输出[1,2,3]，省略起始索引，表示从0开始取，等效于li[0:3]
  print li[:]            #输出[1,2,3,4,5,6,7]，省略起始索引、终止索引、步长值表示取全部，等效于li[0:len(li):1]
  print li[::]           #输出[1,2,3,4,5,6,7]，省略起始索引、终止索引、步长值表示取全部，等效于li[0:len(li):1]
  print li[::-1]        #输出[7,6,5,4,3,2,1]，省略起始索引、终止索引，步长值为-1，表示反向获取
  
  注：在切片运算中，步长为正，表示从左至右，按照索引值与起始位置索引之差可以被步长整除的规律取值；当步长为负，则表示从右至左，按照
  按照索引值与起始位置索引之差可以被步长整除的规律取值。
  根据这个特性，我们可以很方便对某个序列进行倒序取值，这个方法比reverse方法更方便，且适用于没有reverse方法的字符串和元组。
'''
##########################################################
'''
1.列表
  不用声明可以直接使用，并且一个数组中可以存储多种不同的数据类型（包括另外的列表，元组，字典）
  a=['1','2','3']
    list.remove(value)  删除指定的值
    list.pop()  删除末尾的值
    list.insert(index,value) 在指定位置插入值 
    list.reverse() 翻转数组
    list.append(value)  在数组末尾追加一个值
    list.extend(list1)  在数组末尾追加另一个数组
  判断数据类型：
    a = 111
    isinstance(a, int)
    True
'''
